/* automatically generated by rust-bindgen */

use libc;

pub const Argon2_ErrorCodes_ARGON2_OK : Argon2_ErrorCodes = 0 ; pub const Argon2_ErrorCodes_ARGON2_OUTPUT_PTR_NULL : Argon2_ErrorCodes = -1 ; pub const Argon2_ErrorCodes_ARGON2_OUTPUT_TOO_SHORT : Argon2_ErrorCodes = -2 ; pub const Argon2_ErrorCodes_ARGON2_OUTPUT_TOO_LONG : Argon2_ErrorCodes = -3 ; pub const Argon2_ErrorCodes_ARGON2_PWD_TOO_SHORT : Argon2_ErrorCodes = -4 ; pub const Argon2_ErrorCodes_ARGON2_PWD_TOO_LONG : Argon2_ErrorCodes = -5 ; pub const Argon2_ErrorCodes_ARGON2_SALT_TOO_SHORT : Argon2_ErrorCodes = -6 ; pub const Argon2_ErrorCodes_ARGON2_SALT_TOO_LONG : Argon2_ErrorCodes = -7 ; pub const Argon2_ErrorCodes_ARGON2_AD_TOO_SHORT : Argon2_ErrorCodes = -8 ; pub const Argon2_ErrorCodes_ARGON2_AD_TOO_LONG : Argon2_ErrorCodes = -9 ; pub const Argon2_ErrorCodes_ARGON2_SECRET_TOO_SHORT : Argon2_ErrorCodes = -10 ; pub const Argon2_ErrorCodes_ARGON2_SECRET_TOO_LONG : Argon2_ErrorCodes = -11 ; pub const Argon2_ErrorCodes_ARGON2_TIME_TOO_SMALL : Argon2_ErrorCodes = -12 ; pub const Argon2_ErrorCodes_ARGON2_TIME_TOO_LARGE : Argon2_ErrorCodes = -13 ; pub const Argon2_ErrorCodes_ARGON2_MEMORY_TOO_LITTLE : Argon2_ErrorCodes = -14 ; pub const Argon2_ErrorCodes_ARGON2_MEMORY_TOO_MUCH : Argon2_ErrorCodes = -15 ; pub const Argon2_ErrorCodes_ARGON2_LANES_TOO_FEW : Argon2_ErrorCodes = -16 ; pub const Argon2_ErrorCodes_ARGON2_LANES_TOO_MANY : Argon2_ErrorCodes = -17 ; pub const Argon2_ErrorCodes_ARGON2_PWD_PTR_MISMATCH : Argon2_ErrorCodes = -18 ; pub const Argon2_ErrorCodes_ARGON2_SALT_PTR_MISMATCH : Argon2_ErrorCodes = -19 ; pub const Argon2_ErrorCodes_ARGON2_SECRET_PTR_MISMATCH : Argon2_ErrorCodes = -20 ; pub const Argon2_ErrorCodes_ARGON2_AD_PTR_MISMATCH : Argon2_ErrorCodes = -21 ; pub const Argon2_ErrorCodes_ARGON2_MEMORY_ALLOCATION_ERROR : Argon2_ErrorCodes = -22 ; pub const Argon2_ErrorCodes_ARGON2_FREE_MEMORY_CBK_NULL : Argon2_ErrorCodes = -23 ; pub const Argon2_ErrorCodes_ARGON2_ALLOCATE_MEMORY_CBK_NULL : Argon2_ErrorCodes = -24 ; pub const Argon2_ErrorCodes_ARGON2_INCORRECT_PARAMETER : Argon2_ErrorCodes = -25 ; pub const Argon2_ErrorCodes_ARGON2_INCORRECT_TYPE : Argon2_ErrorCodes = -26 ; pub const Argon2_ErrorCodes_ARGON2_OUT_PTR_MISMATCH : Argon2_ErrorCodes = -27 ; pub const Argon2_ErrorCodes_ARGON2_THREADS_TOO_FEW : Argon2_ErrorCodes = -28 ; pub const Argon2_ErrorCodes_ARGON2_THREADS_TOO_MANY : Argon2_ErrorCodes = -29 ; pub const Argon2_ErrorCodes_ARGON2_MISSING_ARGS : Argon2_ErrorCodes = -30 ; pub const Argon2_ErrorCodes_ARGON2_ENCODING_FAIL : Argon2_ErrorCodes = -31 ; pub const Argon2_ErrorCodes_ARGON2_DECODING_FAIL : Argon2_ErrorCodes = -32 ; pub const Argon2_ErrorCodes_ARGON2_THREAD_FAIL : Argon2_ErrorCodes = -33 ; pub const Argon2_ErrorCodes_ARGON2_DECODING_LENGTH_FAIL : Argon2_ErrorCodes = -34 ; pub const Argon2_ErrorCodes_ARGON2_VERIFY_MISMATCH : Argon2_ErrorCodes = -35 ; pub type Argon2_ErrorCodes = i32 ; pub type allocate_fptr = :: std :: option :: Option < unsafe extern "C" fn ( memory : * mut * mut u8 , bytes_to_allocate : usize ) -> libc :: c_int > ; pub type deallocate_fptr = :: std :: option :: Option < unsafe extern "C" fn ( memory : * mut u8 , bytes_to_allocate : usize ) > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct Argon2_Context { pub out : * mut u8 , pub outlen : u32 , pub pwd : * mut u8 , pub pwdlen : u32 , pub salt : * mut u8 , pub saltlen : u32 , pub secret : * mut u8 , pub secretlen : u32 , pub ad : * mut u8 , pub adlen : u32 , pub t_cost : u32 , pub m_cost : u32 , pub lanes : u32 , pub threads : u32 , pub version : u32 , pub allocate_cbk : allocate_fptr , pub free_cbk : deallocate_fptr , pub flags : u32 , } # [ test ] fn bindgen_test_layout_Argon2_Context ( ) { assert_eq ! ( :: std :: mem :: size_of :: < Argon2_Context > ( ) , 120usize , concat ! ( "Size of: " , stringify ! ( Argon2_Context ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < Argon2_Context > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( Argon2_Context ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . out as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( out ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . outlen as * const _ as usize } , 8usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( outlen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . pwd as * const _ as usize } , 16usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( pwd ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . pwdlen as * const _ as usize } , 24usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( pwdlen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . salt as * const _ as usize } , 32usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( salt ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . saltlen as * const _ as usize } , 40usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( saltlen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . secret as * const _ as usize } , 48usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( secret ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . secretlen as * const _ as usize } , 56usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( secretlen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . ad as * const _ as usize } , 64usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( ad ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . adlen as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( adlen ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . t_cost as * const _ as usize } , 76usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( t_cost ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . m_cost as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( m_cost ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . lanes as * const _ as usize } , 84usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( lanes ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . threads as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( threads ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . version as * const _ as usize } , 92usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( version ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . allocate_cbk as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( allocate_cbk ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . free_cbk as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( free_cbk ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: std :: ptr :: null :: < Argon2_Context > ( ) ) ) . flags as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( Argon2_Context ) , "::" , stringify ! ( flags ) ) ) ; } pub type argon2_context = Argon2_Context ; pub const Argon2_type_Argon2_d : Argon2_type = 0 ; pub const Argon2_type_Argon2_i : Argon2_type = 1 ; pub const Argon2_type_Argon2_id : Argon2_type = 2 ; pub type Argon2_type = u32 ; pub use self :: Argon2_type as argon2_type ; extern "C" { # [ link_name = "\u{1}_argon2_ctx" ] pub fn argon2_ctx ( context : * mut argon2_context , type_ : argon2_type ) -> libc :: c_int ; } extern "C" { # [ link_name = "\u{1}_argon2_verify_ctx" ] pub fn argon2_verify_ctx ( context : * mut argon2_context , hash : * const libc :: c_char , type_ : argon2_type ) -> libc :: c_int ; } extern "C" { # [ doc = " Get the associated error message for given error code" ] # [ doc = " @return  The error message associated with the given error code" ] # [ link_name = "\u{1}_argon2_error_message" ] pub fn argon2_error_message ( error_code : libc :: c_int ) -> * const libc :: c_char ; } extern "C" { # [ doc = " Returns the encoded hash length for the given input parameters" ] # [ doc = " @param t_cost  Number of iterations" ] # [ doc = " @param m_cost  Memory usage in kibibytes" ] # [ doc = " @param parallelism  Number of threads; used to compute lanes" ] # [ doc = " @param saltlen  Salt size in bytes" ] # [ doc = " @param hashlen  Hash size in bytes" ] # [ doc = " @param type The argon2_type that we want the encoded length for" ] # [ doc = " @return  The encoded hash length in bytes" ] # [ link_name = "\u{1}_argon2_encodedlen" ] pub fn argon2_encodedlen ( t_cost : u32 , m_cost : u32 , parallelism : u32 , saltlen : u32 , hashlen : u32 , type_ : argon2_type ) -> usize ; } extern "C" { # [ link_name = "\u{1}_encode_string" ] pub fn encode_string ( dst : * mut libc :: c_char , dst_len : usize , ctx : * mut argon2_context , type_ : argon2_type ) -> libc :: c_int ; } extern "C" { # [ link_name = "\u{1}_decode_string" ] pub fn decode_string ( ctx : * mut argon2_context , str : * const libc :: c_char , type_ : argon2_type ) -> libc :: c_int ; }