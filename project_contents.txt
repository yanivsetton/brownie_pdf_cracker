File: ./src/password_list.rs
use rayon::prelude::*;
use super::args::Args;
use std::io::{BufRead, BufReader};

/// Implement the logic for generating the password list here.
pub fn generate_password_list(args: &Args) -> Vec<String> {
    if args.is_numeric {
        let mut password_list: Vec<String> = Vec::new();
        for length in args.smallest_numeric_length..=args.largest_numeric_length {
            password_list.append(
                &mut (0..1000_usize.pow(length as u32))
                    .into_par_iter()
                    .map(|password| format!("{:0width$}", password, width = length))
                    .collect(),
            );
        }
        password_list
    } else if let Some(wordlist) = &args.wordlist {
        let file = std::fs::File::open(wordlist).expect("Unable to open wordlist file");
        let reader = BufReader::new(file);
        reader
            .lines()
            .map(|line| line.expect("Error reading line from wordlist"))
            .collect()
    } else {
        // Default to empty wordlist if no method specified
        Vec::new()
    }
}
################################################################################

File: ./src/yaniv_magic.rs
use indicatif::{ProgressBar, ProgressStyle};
use rand::thread_rng;
use rand::Rng;
use rayon::prelude::*;
use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
use std::sync::{Arc, Mutex};
use super::args::Args;
use super::pdf_crack::try_password;

fn generate_random_password(length: usize) -> String {
    let charset: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let mut rng = thread_rng();
    (0..length)
        .map(|_| {
            let idx = rng.gen_range(0..charset.len());
            charset[idx] as char
        })
        .collect()
}

pub fn yaniv_magic_crack(args: &Args, pdf_bytes: &[u8], progress: &ProgressBar, password_length: usize) {
    let found = Arc::new((AtomicBool::new(false), Mutex::new(None))); // Hold both the flag and the password
    let attempts = Arc::new(AtomicUsize::new(0));
    let total_passwords = 62_usize.pow(password_length as u32);
    progress.set_length(total_passwords as u64);

    let style = ProgressStyle::default_bar()
        .template("{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {pos:>7}/{len:7} ({eta}) Attempting: {msg}")
        .progress_chars("#>-");
    progress.set_style(style);

    (0..total_passwords).into_par_iter().for_each_with(found.clone(), |found, _| {
        if found.0.load(Ordering::Relaxed) {
            return; // If password is found, exit early
        }

        let password = generate_random_password(password_length);
        if try_password(pdf_bytes, &password) {
            found.0.store(true, Ordering::Relaxed);
            let mut found_password = found.1.lock().unwrap();
            *found_password = Some(password.clone());
    
            // Correctly access `args.pdf` here
            let pdf_file_name = args.pdf.trim_end_matches(".pdf");
            let output_file_name = format!("{}_password.txt", pdf_file_name);
    
            // Attempt to write the found password to the file
            match std::fs::write(&output_file_name, password.as_bytes()) {
                Ok(_) => println!("Password successfully found and written to {}", output_file_name),
                Err(e) => println!("Failed to write password to file: {}", e),
            }
    
            return; // Exit the loop early
        }
    

        let current_attempt = attempts.fetch_add(1, Ordering::SeqCst);
        progress.set_position(current_attempt as u64 + 1); // Correctly update the progress position
    });

    // After the parallel processing, check if the password was found and print it
    let was_found = found.0.load(Ordering::Relaxed);
    if was_found {
        let found_password = found.1.lock().unwrap();
        if found_password.is_some() {
            // The password print statement has been moved to the point of discovery above.
            progress.finish_with_message("Password found. Check above for the password.");
        } else {
            println!("Password found but not set correctly.");
            progress.finish_with_message("Password found but not set correctly.");
        }
    } else {
        println!("Password not found.");
        progress.finish_with_message("Password not found.");
    }
}

################################################################################

File: ./src/args.rs
use clap::Parser;

#[derive(Parser, Debug)]
#[command(author = "Warren", version, about, long_about = None)]
pub struct Args {
    #[arg(short, long)]
    pub pdf: String,

    #[arg(short, long)]
    pub wordlist: Option<String>,

    #[arg(short, long, default_value_t = false)]
    pub is_numeric: bool,

    #[arg(short, long, default_value_t = 1)]
    pub smallest_numeric_length: usize,

    #[arg(short, long, default_value_t = 8)]
    pub largest_numeric_length: usize,

    // Add this field to enable yaniv_magic
    #[arg(short, long)]
    pub yaniv_magic: bool,
}

impl Args {
    pub fn parse_args() -> Self {
        Args::parse()
    }
}
################################################################################

File: ./src/pdf_crack.rs
use indicatif::ProgressBar;
use super::args::Args;

pub fn try_password(pdf_contents: &[u8], password: &str) -> bool {
    pdf::file::FileOptions::cached()
        .password(password.as_bytes())
        .load(pdf_contents)
        .is_ok()
}

pub fn crack_pdf(_args: &Args, pdf_bytes: &[u8], password_list: &[String], progress: &ProgressBar) {
    let total_passwords = password_list.len() as u64;
    progress.set_length(total_passwords);
    for password in password_list {
        if try_password(pdf_bytes, password) {
            println!("Found password: {}", password);
            progress.inc(1);
            return;
        }
        progress.inc(1);
    }
}
################################################################################

File: ./src/main.rs
use indicatif::{ProgressBar, ProgressStyle};
use std::fs::read;
use env_logger::Builder;
use log::info;
use std::io;

mod args;
mod pdf_crack;
mod password_list;
mod yaniv_magic;

fn print_banner() {
    let banner = r#"
   / \__
  (    @\____
  /         O
 /   (_____/ 
/_____/   U 

   Brownie PDF Cracker

  ðŸ‘… It's Treat Time! ðŸ¶
"#;
    println!("{}", banner);
}

fn main() {
    Builder::from_env(env_logger::Env::default().default_filter_or("info")).init();
    print_banner();

    let args = args::Args::parse_args();
    let pdf_bytes = read(&args.pdf).expect("Unable to read PDF");
    let password_list = password_list::generate_password_list(&args);

    let password_length: usize;

    if args.yaniv_magic {
        println!("Enter the password length:");
        let mut input = String::new();
        io::stdin().read_line(&mut input).expect("Failed to read input");
        password_length = input.trim().parse().expect("Invalid input");
    } else {
        password_length = args.smallest_numeric_length;
    }

    let progress = ProgressBar::new(62_usize.pow(password_length as u32) as u64);
    let style = ProgressStyle::default_bar()
        .template("[{elapsed_precise}] {bar:45.cyan/blue} {pos:>7}/{len:7} ({eta}) Attempting: {msg}")
        .progress_chars("#>-");
    progress.set_style(style);

    if args.yaniv_magic {
        yaniv_magic::yaniv_magic_crack(&args, &pdf_bytes, &progress, password_length);
    } else {
        pdf_crack::crack_pdf(&args, &pdf_bytes, &password_list, &progress);
    }

    progress.finish();
    info!("Done");
}

################################################################################

