File: ./src/password_list.rs
use rayon::prelude::*;
use super::args::Args;
use std::io::{BufRead, BufReader};

/// Implement the logic for generating the password list here.
pub fn generate_password_list(args: &Args) -> Vec<String> {
    if args.is_numeric {
        let mut password_list: Vec<String> = Vec::new();
        for length in args.smallest_numeric_length..=args.largest_numeric_length {
            password_list.append(
                &mut (0..1000_usize.pow(length as u32))
                    .into_par_iter()
                    .map(|password| format!("{:0width$}", password, width = length))
                    .collect(),
            );
        }
        password_list
    } else if let Some(wordlist) = &args.wordlist {
        let file = std::fs::File::open(wordlist).expect("Unable to open wordlist file");
        let reader = BufReader::new(file);
        reader
            .lines()
            .map(|line| line.expect("Error reading line from wordlist"))
            .collect()
    } else {
        // Default to empty wordlist if no method specified
        Vec::new()
    }
}
################################################################################

File: ./src/yaniv_magic.rs
use indicatif::{ProgressBar, ProgressStyle};
use rayon::prelude::*;
use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
use std::sync::{Arc, Mutex};
use std::time::Instant;
use super::args::Args;
use super::pdf_crack::try_password;

fn generate_and_test_passwords(
    charset: &[u8],
    length: usize,
    pdf_bytes: &[u8],
    found: Arc<(AtomicBool, Mutex<Option<String>>)>,
    attempts: Arc<AtomicUsize>,
    progress: &ProgressBar,
    start_time: Instant,
) {
    let total_combinations = charset.len().pow(length as u32);

    (0..total_combinations).into_par_iter().for_each_with(found.clone(), |found, index| {
        if found.0.load(Ordering::Relaxed) {
            return;
        }

        let mut combination = Vec::with_capacity(length);
        let mut current_index = index;
        for _ in 0..length {
            combination.push(charset[current_index % charset.len()]);
            current_index /= charset.len();
        }
        let password: String = combination.iter().rev().map(|&c| c as char).collect();

        if try_password(pdf_bytes, &password) {
            found.0.store(true, Ordering::Relaxed);
            let mut found_password = found.1.lock().unwrap();
            *found_password = Some(password.clone());
            println!("Password successfully found: {}", password);
            return;
        }

        let current_attempt = attempts.fetch_add(1, Ordering::SeqCst) + 1;
        // Update the progress bar every 100,000 attempts
        if current_attempt % 100_000 == 0 {
            let elapsed = start_time.elapsed().as_secs_f32();
            let attempts_per_sec = current_attempt as f32 / elapsed;
            progress.set_position(current_attempt as u64);
            progress.set_message(format!("Attempts/sec: {:.2}", attempts_per_sec));
        }
    });
}


pub fn yaniv_magic_crack(_args: &Args, pdf_bytes: &[u8], progress: &ProgressBar, password_length: usize) {
    let charset: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let found = Arc::new((AtomicBool::new(false), Mutex::new(None)));
    let attempts = Arc::new(AtomicUsize::new(0));
    let total_passwords = charset.len().pow(password_length as u32);
    progress.set_length(total_passwords as u64);
    let start_time = Instant::now();

    let style = ProgressStyle::default_bar()
        .template("{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {pos:>7}/{len:7} ({eta}) {msg}")
        .progress_chars("#>-");
    progress.set_style(style);

    generate_and_test_passwords(charset, password_length, pdf_bytes, found.clone(), attempts.clone(), progress, start_time);

    let was_found = found.0.load(Ordering::Relaxed);
    if was_found {
        let found_password = found.1.lock().unwrap();
        if let Some(password) = &*found_password {
            println!("Password successfully found: {}", password);
            progress.finish_with_message("Password found. Check output for details.");
        } else {
            progress.finish_with_message("Password found but not set correctly.");
        }
    } else {
        progress.finish_with_message("Password not found.");
    }
}
################################################################################

File: ./src/args.rs
use clap::Parser;

#[derive(Parser, Debug)]
#[command(author = "Warren", version, about, long_about = None)]
pub struct Args {
    #[arg(short, long)]
    pub pdf: String,

    #[arg(short, long)]
    pub wordlist: Option<String>,

    #[arg(short, long, default_value_t = false)]
    pub is_numeric: bool,

    #[arg(short, long, default_value_t = 1)]
    pub smallest_numeric_length: usize,

    #[arg(short, long, default_value_t = 8)]
    pub largest_numeric_length: usize,

    // Add this field to enable yaniv_magic
    #[arg(short, long)]
    pub yaniv_magic: bool,

    // New field for specifying password length directly
    #[arg(short = 'n', long = "password-length")]
    pub password_length: Option<usize>,
}

impl Args {
    pub fn parse_args() -> Self {
        Args::parse()
    }
}
################################################################################

File: ./src/pdf_crack.rs
use indicatif::ProgressBar;
use super::args::Args;

pub fn try_password(pdf_contents: &[u8], password: &str) -> bool {
    pdf::file::FileOptions::cached()
        .password(password.as_bytes())
        .load(pdf_contents)
        .is_ok()
}

pub fn crack_pdf(_args: &Args, pdf_bytes: &[u8], password_list: &[String], progress: &ProgressBar) {
    let total_passwords = password_list.len() as u64;
    progress.set_length(total_passwords);
    for password in password_list {
        if try_password(pdf_bytes, password) {
            println!("Found password: {}", password);
            progress.inc(1);
            return;
        }
        progress.inc(1);
    }
}
################################################################################

File: ./src/main.rs
use indicatif::{ProgressBar, ProgressStyle};
use std::fs::read;
use env_logger::Builder;
use log::info;
use std::io;

mod args;
mod pdf_crack;
mod password_list;
mod yaniv_magic;

fn print_banner() {
    let banner = r#"
   / \__
  (    @\____
  /         O
 /   (_____/ 
/_____/   U 

   Brownie PDF Cracker

  ðŸ‘… It's Treat Time! ðŸ¶
"#;
    println!("{}", banner);
}

fn main() {
    Builder::from_env(env_logger::Env::default().default_filter_or("info")).init();
    print_banner();

    let args = args::Args::parse_args();
    let pdf_bytes = read(&args.pdf).expect("Unable to read PDF");
    let password_list = password_list::generate_password_list(&args);

    let password_length = if args.yaniv_magic {
        // Use the provided password length if available, otherwise prompt for it
        args.password_length.unwrap_or_else(|| {
            println!("Enter the password length:");
            let mut input = String::new();
            io::stdin().read_line(&mut input).expect("Failed to read input");
            input.trim().parse().expect("Invalid input")
        })
    } else {
        args.smallest_numeric_length
    };

    let progress = ProgressBar::new(62_usize.pow(password_length as u32) as u64);
    let style = ProgressStyle::default_bar()
        .template("[{elapsed_precise}] {bar:45.cyan/blue} {pos:>7}/{len:7} ({eta}) Attempting: {msg}")
        .progress_chars("#>-");
    progress.set_style(style);

    if args.yaniv_magic {
        yaniv_magic::yaniv_magic_crack(&args, &pdf_bytes, &progress, password_length);
    } else {
        pdf_crack::crack_pdf(&args, &pdf_bytes, &password_list, &progress);
    }

    progress.finish();
    info!("Done");
}

################################################################################

